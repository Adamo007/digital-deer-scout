{"name": "Cloud Terrain Ai App", "type": "code/python", "content": "import streamlit as st\nimport geopandas as gpd\nimport pandas as pd\nfrom shapely.geometry import Point, LineString\nimport tempfile\nimport rasterio\nimport numpy as np\nimport os\nfrom rasterio.mask import mask\nfrom zipfile import ZipFile\nimport requests\nfrom scipy.ndimage import gaussian_filter\nimport pydeck as pdk\nfrom rasterio.transform import rowcol\nfrom skimage.filters import sobel\nimport base64\nfrom sentinelhub import SHConfig, SentinelHubRequest, DataCollection, BBox, CRS, MimeType\n\nst.set_page_config(page_title="Digital Deer Scout AI", layout="wide")\nst.title("ðŸ¦Œ Digital Deer Scout â€“ Terrain AI")\n\n# --- Sidebar Controls ---\nst.sidebar.header("ðŸ§  Scouting Parameters")\nwind = st.sidebar.selectbox("Wind Direction", ["NW", "W", "SW", "S", "SE", "E", "NE", "N"])\nphase = st.sidebar.selectbox("Target Phase", ["Early Season", "Pre-Rut", "Rut"])\naggression = st.sidebar.slider("Pin Aggression Level", 1, 10, 8)\nshow_buck_beds = st.sidebar.checkbox("Show Buck Bedding", True)\nshow_doe_beds = st.sidebar.checkbox("Show Doe Bedding", True)\nshow_scrapes = st.sidebar.checkbox("Show Scrape Locations", True)\nshow_funnels = st.sidebar.checkbox("Show Funnels", True)\ncustom_tiff = st.sidebar.file_uploader("Upload GeoTIFF (DEM)", type=["tif", "tiff"])\ncustom_ndvi = st.sidebar.file_uploader("Upload NDVI GeoTIFF (optional)", type=["tif", "tiff"])\n\n# --- File Upload ---\nuploaded_file = st.file_uploader("Upload KML or KMZ hunt boundary file", type=["kml", "kmz"])\n\n# --- Extract Geometry ---\ndef extract_kml(file) -> gpd.GeoDataFrame:\n try:\n if file.name.endswith(".kmz"):\n with ZipFile(file) as zf:\n kml_file = [f for f in zf.namelist() if f.endswith(".kml")][0]\n with zf.open(kml_file) as kmldata:\n gdf = gpd.read_file(kmldata)\n else:\n gdf = gpd.read_file(file)\n return gdf.to_crs("EPSG:4326")\n except Exception as e:\n st.error(f"KML/KMZ parsing failed: {e}")\n st.stop()\n\n# --- DEM Fetch ---\ndef fetch_usgs_lidar(bounds, out_path="dem.tif"):\n minx, miny, maxx, maxy = bounds\n url = (\n f"https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?bbox={minx},{miny},{maxx},{maxy}\"\n "&bboxSR=4326&imageSR=4326&format=tiff&pixelType=F32&f=image"\n )\n r = requests.get(url)\n if r.status_code == 200 and r.headers.get("Content-Type") == "image/tiff":\n with open(out_path, "wb") as f:\n f.write(r.content)\n return out_path\n raise Exception("USGS DEM download failed")\n\n# --- NDVI Fetch ---\ndef fetch_ndvi(bounds, client_id, client_secret, out_path="ndvi.tif"):\n config = SHConfig()\n config.sh_client_id = client_id\n config.sh_client_secret = client_secret\n config.save()\n bbox = BBox(bbox=bounds, crs=CRS.WGS84)\n evalscript = """\n //VERSION=3\n function setup() {\n return {\n input: ["B04", "B08"],\n output: { bands: 1 }\n };\n }\n function evaluatePixel(sample) {\n let ndvi = (sample.B08 - sample.B04) / (sample.B08 + sample.B04);\n return [ndvi];\n }\n """\n request = SentinelHubRequest(\n evalscript=evalscript,\n input_data=[SentinelHubRequest.input_data(data_collection=DataCollection.SENTINEL2_L2A)],\n responses=[SentinelHubRequest.output_response("default", MimeType.TIFF)],\n bbox=bbox,\n size=(512, 512),\n config=config,\n data_folder=tempfile.gettempdir()\n )\n data = request.get_data(save_data=True)\n if isinstance(data[0], np.ndarray):\n with rasterio.open(out_path, 'w', driver='GTiff', height=data[0].shape[0], width=data[0].shape[1], count=1,\n dtype=str(data[0].dtype), crs='EPSG:4326',\n transform=rasterio.transform.from_bounds(*bounds, data[0].shape[1], data[0].shape[0])) as dst:\n dst.write(data[0], 1)\n return out_path\n return None\n\n# --- Main Workflow ---\nif uploaded_file:\n gdf = extract_kml(uploaded_file)\n poly = gdf.geometry.iloc[0]\n st.success("âœ… KML Loaded")\n \n # DEM\n try:\n dem_path = fetch_usgs_lidar(poly.bounds) if not custom_tiff else tempfile.NamedTemporaryFile(delete=False).name\n if custom_tiff: open(dem_path, 'wb').write(custom_tiff.read())\n st.success("âœ… DEM Loaded")\n except Exception as e:\n st.error(f"DEM Error: {e}")\n st.stop()\n\n # NDVI\n ndvi_path = None\n client_id = st.secrets.get("SENTINEL_CLIENT_ID", "")\n client_secret = st.secrets.get("SENTINEL_CLIENT_SECRET", "")\n if client_id and client_secret:\n ndvi_path = fetch_ndvi(poly.bounds, client_id, client_secret)\n st.success("âœ… NDVI Loaded")\n\n # --- Terrain Analysis ---\n with rasterio.open(dem_path) as src:\n out_image, out_transform = mask(src, [poly], crop=True, nodata=np.nan)\n elevation = out_image[0].astype(float)\n elevation = gaussian_filter(elevation, sigma=2.0)\n dx, dy = np.gradient(elevation, src.res[0] * 111320)\n slope = np.degrees(np.arctan(np.sqrt(dx2 + dy2)))\n aspect = np.degrees(np.arctan2(-dx, dy)) % 360\n tpi = elevation - gaussian_filter(elevation, sigma=5)\n\n # --- Candidate Generation ---\n step = max((poly.bounds[2] - poly.bounds[0]) / (aggression * 100), 0.00005)\n x_coords = np.arange(poly.bounds[0], poly.bounds[2], step)\n y_coords = np.arange(poly.bounds[1], poly.bounds[3], step)\n candidate_pts = [Point(x, y) for x in x_coords for y in y_coords if poly.contains(Point(x, y))]\n\n buck_pts, doe_pts, scrape_pts = [], [], []\n for pt in candidate_pts:\n try:\n row, col = rowcol(out_transform, pt.x, pt.y)\n if row < 0 or col < 0: continue\n s, a, elev, tpi_val = slope[row, col], aspect[row, col], elevation[row, col], tpi[row, col]\n wind_match = ((wind == "W" and 180 < a < 360) or (wind == "S" and 90 < a < 270))\n if show_buck_beds and 0.005 < s < 40 and tpi_val > 0.1 and wind_match:\n buck_pts.append(pt)\n if show_doe_beds and s < 25:\n doe_pts.append(pt)\n except Exception:\n continue\n\n # --- KML Export ---\n pins = []\n if show_buck_beds:\n pins += [{"lon": p.x, "lat": p.y, "type": "Buck", "color": [255, 0, 0]} for p in buck_pts]\n if show_doe_beds:\n pins += [{"lon": p.x, "lat": p.y, "type": "Doe", "color": [255, 255, 0]} for p in doe_pts]\n \n if pins and st.button("Export KML"):\n df = pd.DataFrame(pins)\n gdf_out = gpd.GeoDataFrame(df, geometry=[Point(row['lon'], row['lat']) for _, row in df.iterrows()], crs="EPSG:4326")\n tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".kml")\n gdf_out.to_file(tmp.name, driver="KML")\n with open(tmp.name, "rb") as f:\n b64 = base64.b64encode(f.read()).decode()\n href = f'<a href="data:application/octet-stream;base64,{b64}" download="scout_output.kml">Download KML</a>'\n st.markdown(href, unsafe_allow_html=True)\n\nelse:\n st.info("Please upload a KML or KMZ file to begin.")"}

